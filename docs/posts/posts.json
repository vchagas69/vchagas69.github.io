[
  {
    "path": "posts/2022-08-07-r-memory-management/",
    "title": "R memory management",
    "description": "In this post we present a classic finance use case using the PerformanceAnalytics, quantmod, and dygraphs packages. We'll demonstrate importing stock data, building a portfolio, and then calculating the Sharpe Ratio.",
    "author": [],
    "date": "2022-08-07",
    "categories": [
      "portfolio theory",
      "dygraphs"
    ],
    "contents": "\n\nContents\nOverview\nSetting up\nPreparing the data\nCalculating portfolio\nreturns\nCalculating the Sharpe\nRatio\n\nOverview\nIn this post we’ll demonstrate the calculation of a Sharpe Ratio for\na stock portfolio. We’ll start with a function that grabs monthly stock\nreturns and saves those monthly returns as an xts object in the global\nenvironment. With that function, we will create three xts objects of\nmonthly returns, and merge those three xts objects into one object,\nbefore passing that merged object to dygraphs to peek at the individual\nstocks.\nThen, we’ll move on to build a portfolio by selecting asset weights\nand calculating the portfolio monthly returns. Next, we will calculate\nthe growth of a dollar invested in that portfolio (which is what matters\nto us) over time, and save the results to an xts object. Dygraphs will\ncome in handy again for the portfolio visualizations. Finally, we will\ncalculate the Sharpe Ratio.\nSetting up\nWe start by loading three packages: quantmod to download the data,\nPerformanceAnalytics to run portfolio calculations, and dygraphs to\ngraph time series objects. We will also create a function to import\nstock data.\n\n\nlibrary(PerformanceAnalytics)\nlibrary(quantmod)\nlibrary(dygraphs)\n\n# Function to calculate monthly returns on a stock \nmonthly_stock_returns <- function(ticker, start_year) {\n  \n  # Download the data from Yahoo finance\n  symbol <- getSymbols(ticker, src = 'yahoo', \n                       auto.assign = FALSE, warnings = FALSE)\n  \n  # Tranform it to monthly returns using quantmode::periodReturn\n  data <- periodReturn(symbol, period = 'monthly', \n                       subset=paste(start_year, \"::\", sep = \"\"),\n                       type = 'log')\n\n  # Let's rename the column of returns to something intuitive because\n  # the column name is what will eventually be displayed\n  colnames(data) <- as.character(ticker)\n\n  # We want to be able to work with the xts objects so let's explicitly\n  # assign them into the global environment using ticker name \n  assign(ticker, data, .GlobalEnv)\n}\n\n\nThe monthly_stock_returns function above takes 2\nparameters, a stock symbol and a year. Note that we could have included\na third parameter called something like ‘period’ if we wanted the\nability to grab periods other than monthly returns. For example, we can\nenvision a desire to look at annual, weekly or daily returns. Here, I\nforce monthly returns because I don’t want to allow different period\noptions. It’s a choice driven by the purpose of this Notebook - which\nhere is focused on monthly returns.\nPreparing the data\nIn the next chunk, we choose three stock tickers and a starting year\nargument for the monthly_stock_returns function. Then, we\nmerge them into one xts object.\n\n\n# Choose the starting year and assign it to the 'year' variable\nyear <- 2010\n\n# Use the function the monthly returns on 3 stocks, and pass in the 'year'\n# value. Let's choose Google, JP Morgan and Amazon\nmonthly_stock_returns('GOOG', year)\nmonthly_stock_returns('JPM', year)\nmonthly_stock_returns('AMZN', year)\n\n# Merge the 3 monthly return xts objects into 1 xts object.\nmerged_returns <- merge.xts(GOOG, JPM, AMZN)\n\n\nLet’s graph the individual performances of each stock over time.\n\n\n# Before we combine these into a portfolio, graph the individual returns\n# and see if anything jumps out as unusual. It looks like something \n# affected Google in March of 2014, but didn't affect JP Morgan or Amazon.\ndygraph(merged_returns, main = \"Google v JP Morgan v Amazon\") %>%\n  dyAxis(\"y\", label = \"%\") %>%\n  dyOptions(colors = RColorBrewer::brewer.pal(3, \"Set2\"))\n\n\n\nNothing earth-shattering thus far: we have an xts object of three\ntime series and have seen that one of them had weird behavior in April\nof 2014 (a Google stock split). We’ll ignore that behavior for this\nexample and go on to constructing a portfolio.\nCalculating portfolio\nreturns\nHere we’ll find the monthly returns of a weighted combination of\nassets. Unsurprisingly, we start out by choosing those weights.\n\n\n# We have the 3 monthly returns saved in 1 object.\n# Now, let's choose the respective weights of those 3.\n# Here we'll allocate 25% to Google, 25% to JP Morgan and 50% to Amazon.\nw <- c(.25, .25, .50)\n\n# Now use the built in PerformanceAnalytics function Return.portfolio\n# to calculate the monthly returns on the portfolio,\nportfolio_monthly_returns <- Return.portfolio(merged_returns, weights = w)\n\n# Use dygraphs to chart the portfolio monthly returns.\ndygraph(portfolio_monthly_returns, main = \"Portfolio Monthly Return\") %>%\n  dyAxis(\"y\", label = \"%\")\n\n\n\nNow, instead of looking at monthly returns, let’s look at how $1\nwould have grown in this portfolio.\n\n\n# Add the wealth.index = TRUE argument and, instead of monthly returns,\n# the function will return the growth of $1 invested in the portfolio.\ndollar_growth <- Return.portfolio(merged_returns, weights = w, \n                                  wealth.index = TRUE)\n\n# Use dygraphs to chart the growth of $1 in the portfolio.\ndygraph(dollar_growth, main = \"Growth of $1 Invested in Portfolio\") %>%\n  dyAxis(\"y\", label = \"$\")\n\n\n\nA dollar would have grown quite nicely in this portfolio - about 2.5x\n- fantastic.\nCalculating the Sharpe Ratio\nNow let’s look at the risk/reward of this portfolio by calculating\nthe Sharpe Ratio. Briefly, the Sharpe Ratio is the mean of the excess\nmonthly returns above the risk-free rate, divided by the standard\ndeviation of the excess monthly returns above the risk-free rate. This\nis the formulation of the Sharpe Ratio as of 1994; if we wished to use\nthe original formulation from 1966 the denominator would be the standard\ndeviation of portfolio monthly returns. Learn more here.\nIn other words, the Sharpe Ratio measures excess returns per unit of\nvolatility, where we take the standard deviation to represent portfolio\nvolatility. The Sharpe Ratio was brought to us by Bill Sharpe - arguably\nthe most important economist for modern investment management as the\ncreator of the Sharpe Ratio, CAPM and Financial Engines, a forerunner of\ntoday’s robo-advisor movement.\nIn the code chunk below, we’ll calculate the Sharpe Ratio in two\nways.\nFirst, we’ll use the Return.excess function from PerformanceAnalytics\nto calculate a time series of monthly excess returns. Two arguments need\nto be supplied: the time series of returns and the risk-free rate. The\nfunction will return a time series of excess returns, and we’ll take the\nmean of that time series to get the numerator of the Sharpe Ratio. Then\nwe’ll divide by the standard deviation of the that time series to get\nthe Sharpe Ratio.\nOur second method is a bit easier. We’ll use the SharpeRatio function\nin PerformanceAnalytics, for which we’ll supply two arguments: a time\nseries of monthly returns and risk-free rate.\nFor both methods I use a risk-free rate of .03% as the approximate\nmean of the 1-month Treasury bill rate since 2010. I’ll cover a quick\nway to grab this and other data via Quandl in a future post.\n\n\n# Method 1: use the Return.excess function from PerformanceAnalytics,\n# then calculate the Sharpe Ratio manually.\nportfolio_excess_returns <- Return.excess(portfolio_monthly_returns, \n                                          Rf = .0003)\nsharpe_ratio_manual <- round(\n  mean(portfolio_excess_returns) / StdDev(portfolio_excess_returns), 4\n)\n\n# If we wanted to use the original, 1966 formulation of the Sharpe Ratio,\n# there is one small change to the code in Method 1\nsharpe_ratio <- round(\n  SharpeRatio(portfolio_monthly_returns, Rf = .0003), 4\n)\n\n\nUsing the Return.excess function and then dividing by the standard\ndeviation of excess returns, the Sharpe Ratio is\nsharpe_ratio_manual[,1] = 0.2247.\nUsing the built in SharpeRatio function, the Sharpe Ratio is\nsharpe_ratio[1,] = 0.2247.\nAlright, we have built a portfolio and calculated the Sharpe Ratio -\nand also set up some nice reusable chunks for data import, portfolio\nconstruction and visualization. We haven’t done anything terribly\ncomplex but this can serve as a useful paradigm to any collaborators,\nincluding our future selves, who want to reproduce this work, learn from\nthis work, or expand upon this work.\n\n\n\n",
    "preview": "posts/2022-08-07-r-memory-management/preview.png",
    "last_modified": "2022-08-07T19:34:21+00:00",
    "input_file": {},
    "preview_width": 1644,
    "preview_height": 1014
  },
  {
    "path": "posts/2016-11-08-sharpe-ratio/",
    "title": "The Sharpe Ratio",
    "description": "In this post we present a classic finance use case using the PerformanceAnalytics, quantmod, and dygraphs packages. We'll demonstrate importing stock data, building a portfolio, and then calculating the Sharpe Ratio.",
    "author": [],
    "date": "2016-11-08",
    "categories": [
      "portfolio theory",
      "dygraphs"
    ],
    "contents": "\n\nContents\nOverview\nSetting up\nPreparing the data\nCalculating portfolio returns\nCalculating the Sharpe Ratio\n\nOverview\nIn this post we’ll demonstrate the calculation of a Sharpe Ratio for a stock portfolio. We’ll start with a function that grabs monthly stock returns and saves those monthly returns as an xts object in the global environment. With that function, we will create three xts objects of monthly returns, and merge those three xts objects into one object, before passing that merged object to dygraphs to peek at the individual stocks.\nThen, we’ll move on to build a portfolio by selecting asset weights and calculating the portfolio monthly returns. Next, we will calculate the growth of a dollar invested in that portfolio (which is what matters to us) over time, and save the results to an xts object. Dygraphs will come in handy again for the portfolio visualizations. Finally, we will calculate the Sharpe Ratio.\nSetting up\nWe start by loading three packages: quantmod to download the data, PerformanceAnalytics to run portfolio calculations, and dygraphs to graph time series objects. We will also create a function to import stock data.\n\n\nlibrary(PerformanceAnalytics)\nlibrary(quantmod)\nlibrary(dygraphs)\n\n# Function to calculate monthly returns on a stock \nmonthly_stock_returns <- function(ticker, start_year) {\n  \n  # Download the data from Yahoo finance\n  symbol <- getSymbols(ticker, src = 'yahoo', \n                       auto.assign = FALSE, warnings = FALSE)\n  \n  # Tranform it to monthly returns using quantmode::periodReturn\n  data <- periodReturn(symbol, period = 'monthly', \n                       subset=paste(start_year, \"::\", sep = \"\"),\n                       type = 'log')\n\n  # Let's rename the column of returns to something intuitive because\n  # the column name is what will eventually be displayed\n  colnames(data) <- as.character(ticker)\n\n  # We want to be able to work with the xts objects so let's explicitly\n  # assign them into the global environment using ticker name \n  assign(ticker, data, .GlobalEnv)\n}\n\n\n\nThe monthly_stock_returns function above takes 2 parameters, a stock symbol and a year. Note that we could have included a third parameter called something like ‘period’ if we wanted the ability to grab periods other than monthly returns. For example, we can envision a desire to look at annual, weekly or daily returns. Here, I force monthly returns because I don’t want to allow different period options. It’s a choice driven by the purpose of this Notebook - which here is focused on monthly returns.\nPreparing the data\nIn the next chunk, we choose three stock tickers and a starting year argument for the monthly_stock_returns function. Then, we merge them into one xts object.\n\n\n# Choose the starting year and assign it to the 'year' variable\nyear <- 2010\n\n# Use the function the monthly returns on 3 stocks, and pass in the 'year'\n# value. Let's choose Google, JP Morgan and Amazon\nmonthly_stock_returns('GOOG', year)\nmonthly_stock_returns('JPM', year)\nmonthly_stock_returns('AMZN', year)\n\n# Merge the 3 monthly return xts objects into 1 xts object.\nmerged_returns <- merge.xts(GOOG, JPM, AMZN)\n\n\n\nLet’s graph the individual performances of each stock over time.\n\n\n# Before we combine these into a portfolio, graph the individual returns\n# and see if anything jumps out as unusual. It looks like something \n# affected Google in March of 2014, but didn't affect JP Morgan or Amazon.\ndygraph(merged_returns, main = \"Google v JP Morgan v Amazon\") %>%\n  dyAxis(\"y\", label = \"%\") %>%\n  dyOptions(colors = RColorBrewer::brewer.pal(3, \"Set2\"))\n\n\n\n\nNothing earth-shattering thus far: we have an xts object of three time series and have seen that one of them had weird behavior in April of 2014 (a Google stock split). We’ll ignore that behavior for this example and go on to constructing a portfolio.\nCalculating portfolio returns\nHere we’ll find the monthly returns of a weighted combination of assets. Unsurprisingly, we start out by choosing those weights.\n\n\n# We have the 3 monthly returns saved in 1 object.\n# Now, let's choose the respective weights of those 3.\n# Here we'll allocate 25% to Google, 25% to JP Morgan and 50% to Amazon.\nw <- c(.25, .25, .50)\n\n# Now use the built in PerformanceAnalytics function Return.portfolio\n# to calculate the monthly returns on the portfolio,\nportfolio_monthly_returns <- Return.portfolio(merged_returns, weights = w)\n\n# Use dygraphs to chart the portfolio monthly returns.\ndygraph(portfolio_monthly_returns, main = \"Portfolio Monthly Return\") %>%\n  dyAxis(\"y\", label = \"%\")\n\n\n\n\nNow, instead of looking at monthly returns, let’s look at how $1 would have grown in this portfolio.\n\n\n# Add the wealth.index = TRUE argument and, instead of monthly returns,\n# the function will return the growth of $1 invested in the portfolio.\ndollar_growth <- Return.portfolio(merged_returns, weights = w, \n                                  wealth.index = TRUE)\n\n# Use dygraphs to chart the growth of $1 in the portfolio.\ndygraph(dollar_growth, main = \"Growth of $1 Invested in Portfolio\") %>%\n  dyAxis(\"y\", label = \"$\")\n\n\n\n\nA dollar would have grown quite nicely in this portfolio - about 2.5x - fantastic.\nCalculating the Sharpe Ratio\nNow let’s look at the risk/reward of this portfolio by calculating the Sharpe Ratio. Briefly, the Sharpe Ratio is the mean of the excess monthly returns above the risk-free rate, divided by the standard deviation of the excess monthly returns above the risk-free rate. This is the formulation of the Sharpe Ratio as of 1994; if we wished to use the original formulation from 1966 the denominator would be the standard deviation of portfolio monthly returns. Learn more here.\nIn other words, the Sharpe Ratio measures excess returns per unit of volatility, where we take the standard deviation to represent portfolio volatility. The Sharpe Ratio was brought to us by Bill Sharpe - arguably the most important economist for modern investment management as the creator of the Sharpe Ratio, CAPM and Financial Engines, a forerunner of today’s robo-advisor movement.\nIn the code chunk below, we’ll calculate the Sharpe Ratio in two ways.\nFirst, we’ll use the Return.excess function from PerformanceAnalytics to calculate a time series of monthly excess returns. Two arguments need to be supplied: the time series of returns and the risk-free rate. The function will return a time series of excess returns, and we’ll take the mean of that time series to get the numerator of the Sharpe Ratio. Then we’ll divide by the standard deviation of the that time series to get the Sharpe Ratio.\nOur second method is a bit easier. We’ll use the SharpeRatio function in PerformanceAnalytics, for which we’ll supply two arguments: a time series of monthly returns and risk-free rate.\nFor both methods I use a risk-free rate of .03% as the approximate mean of the 1-month Treasury bill rate since 2010. I’ll cover a quick way to grab this and other data via Quandl in a future post.\n\n\n# Method 1: use the Return.excess function from PerformanceAnalytics,\n# then calculate the Sharpe Ratio manually.\nportfolio_excess_returns <- Return.excess(portfolio_monthly_returns, \n                                          Rf = .0003)\nsharpe_ratio_manual <- round(\n  mean(portfolio_excess_returns) / StdDev(portfolio_excess_returns), 4\n)\n\n# If we wanted to use the original, 1966 formulation of the Sharpe Ratio,\n# there is one small change to the code in Method 1\nsharpe_ratio <- round(\n  SharpeRatio(portfolio_monthly_returns, Rf = .0003), 4\n)\n\n\n\nUsing the Return.excess function and then dividing by the standard deviation of excess returns, the Sharpe Ratio is sharpe_ratio_manual[,1] = 0.2805.\nUsing the built in SharpeRatio function, the Sharpe Ratio is sharpe_ratio[1,] = 0.2805.\nAlright, we have built a portfolio and calculated the Sharpe Ratio - and also set up some nice reusable chunks for data import, portfolio construction and visualization. We haven’t done anything terribly complex but this can serve as a useful paradigm to any collaborators, including our future selves, who want to reproduce this work, learn from this work, or expand upon this work.\n\n\n\n",
    "preview": "posts/2016-11-08-sharpe-ratio/preview.png",
    "last_modified": "2022-08-07T17:06:43+00:00",
    "input_file": {},
    "preview_width": 1644,
    "preview_height": 1014
  },
  {
    "path": "posts/2013-08-10-mapping-earthquakes-over-the-past-30-days/",
    "title": "Mapping Earthquakes Over the Past 30 Days",
    "description": "In this post we present a classic finance use case using the PerformanceAnalytics, quantmod, and dygraphs packages. We'll demonstrate importing stock data, building a portfolio, and then calculating the Sharpe Ratio.",
    "author": [
      {
        "name": "Vitor Chagas",
        "url": {}
      }
    ],
    "date": "2013-08-10",
    "categories": [
      "R"
    ],
    "contents": "\n\nContents\nIntroduction\nThe Code\n\nIntroduction\nAfter reading this post I decided to try it and adapt to my own needs.\nThis is just a simple example that uses real-time data from the U.S. Geological Survey.\nThis shows the location of earthquakes with any magnitude over the last month around Puerto Rico (just had to pick some place with earthquakes!).\nThe Code\n\n\n#===========================================================================\n# project : aportugueseactuary.blogspot.pt\n#  script : Mapping_Earthquakes_Over_the_Past30_Days.R\n#  author : Vitor Chagas\n# updated : 2013.08.10\n#===========================================================================\n\n#---------------------------------------------------------------------------\n# reset workspace\n#---------------------------------------------------------------------------\n\nrm(list = ls())\ngc()\n\n#---------------------------------------------------------------------------\n# create & set work directory root\n#---------------------------------------------------------------------------\n\n# change as needed\nworkdir <- '.'\n\ndir.create(workdir, recursive=TRUE)\nsetwd(workdir)\nrm(workdir)\n\n#---------------------------------------------------------------------------\n# create folder tree (needed folders)\n#---------------------------------------------------------------------------\n\n#dir.create('data')\n\n#---------------------------------------------------------------------------\n# install & load necessary packages\n#---------------------------------------------------------------------------\n\nnecessary = c('ggmap')\n\ninstalled = necessary %in% .packages(all.available = TRUE)\n\n# install\nif (length(necessary[!installed]) >=1) \n  install.packages(necessary[!installed])\n\n# load\nfor(pkg in necessary) \n  library(pkg, character.only=TRUE)  \n\nrm(necessary, installed, pkg)\n\n#---------------------------------------------------------------------------\n# get earthquake data\n#---------------------------------------------------------------------------\n\nfile.url <- c(\n  url='http://earthquake.usgs.gov/',\n  path='earthquakes/feed/v1.0/summary/',\n  file='all_month.csv'\n  )\n\neq <- read.table(file=paste(file.url, collapse=''),\n                 fill=TRUE, sep=',', header=TRUE)\n\n# rename columns\nnames(eq)[2] <- 'lat'\nnames(eq)[3] <- 'lon'\n\n# discretize magnitude into 5 intervals\neq$mag.size <- findInterval(eq$mag, c(0,2,4,6,8,10))\n\n#---------------------------------------------------------------------------\n# generate map\n#---------------------------------------------------------------------------\n\n# map center (some place with earthquakes)\ncenter <- geocode('Puerto Rico')\nlocation <- c(center$lon,center$lat)\n\n# get map from Google\nmap <- get_map(location = location, zoom=7, maptype='roadmap')\n\n# display earthquake data\nggmap(map, extent = 'device') +\n  geom_point(data=eq,\n             mapping=aes(x = lon, y = lat, colour=mag)) + \n  scale_colour_gradient(limits=c(0, 9.9), low=\"yellow\", high=\"red\")\n\n\n\n\n\n\n",
    "preview": {},
    "last_modified": "2022-08-07T17:06:43+00:00",
    "input_file": {}
  },
  {
    "path": "posts/2012-07-29/",
    "title": "Puppy Linux : How to create an ISO image from a CD",
    "description": "In this post we present a classic finance use case using the PerformanceAnalytics, quantmod, and dygraphs packages. We'll demonstrate importing stock data, building a portfolio, and then calculating the Sharpe Ratio.",
    "author": [],
    "date": "2012-07-29",
    "categories": [
      "puppy",
      "linux"
    ],
    "contents": "\n\nContents\nOverview\n\nOverview\nPut CD into the optical drive but don’t mount it.\nTOpen a terminal screen (console).\nJust to be on the safe side, verify if it is mounted or not with the mount command.\n\nls -l\ntotal 52\ndrwxr-xr-x 9 root root  4096 Apr  3 01:18 create-iso-from-cd_files\n-rw-r--r-- 1 root root 42534 Apr  3 01:18 create-iso-from-cd.html\n-rw-r--r-- 1 spot spot   700 Apr  3 01:13 create-iso-from-cd.Rmd\n\n\n\n\n",
    "preview": {},
    "last_modified": "2022-08-07T17:06:43+00:00",
    "input_file": {}
  },
  {
    "path": "posts/2010-07-11-manage-the-available-memory-in-an-r-session/",
    "title": "Manage the available memory in an R session",
    "description": "A small function to manage memory in R.",
    "author": [
      {
        "name": "Vitor Chagas",
        "url": "https://vchagas69.github.io"
      }
    ],
    "date": "2010-07-11",
    "categories": [
      "r-project"
    ],
    "contents": "\nMemory is something that we always need to keep track of in R.\nHere’s a nice trick found in stackoverflow.com\n\n\n# improved list of objects\n.ls.objects <- function(pos = 1, pattern, order.by, decreasing = FALSE, head = FALSE, \n    n = 5) {\n    napply <- function(names, fn) sapply(names, function(x) fn(get(x, pos = pos)))\n    names <- ls(pos = pos, pattern = pattern)\n    obj.class <- napply(names, function(x) as.character(class(x))[1])\n    obj.mode <- napply(names, mode)\n    obj.type <- ifelse(is.na(obj.class), obj.mode, obj.class)\n    obj.size <- napply(names, object.size)\n    obj.prettysize <- sapply(obj.size, function(r) prettyNum(r, big.mark = \",\"))\n    obj.dim <- t(napply(names, function(x) as.numeric(dim(x))[1:2]))\n    vec <- is.na(obj.dim)[, 1] & (obj.type != \"function\")\n    obj.dim[vec, 1] <- napply(names, length)[vec]\n    out <- data.frame(obj.type, obj.size, obj.prettysize, obj.dim)\n    names(out) <- c(\"Type\", \"Size\", \"PrettySize\", \"Rows\", \"Columns\")\n    if (!missing(order.by)) \n        out <- out[order(out[[order.by]], decreasing = decreasing), ]\n    out <- out[c(\"Type\", \"PrettySize\", \"Rows\", \"Columns\")]\n    names(out) <- c(\"Type\", \"Size\", \"Rows\", \"Columns\")\n    if (head) \n        out <- head(out, n)\n    out\n}\n\n# shorthand\nlsos <- function(..., n = 10) {\n    .ls.objects(..., order.by = \"Size\", decreasing = TRUE, head = TRUE, n = n)\n}\n\n\nThis one is going to my .Rprofile.\n\n\n\n",
    "preview": {},
    "last_modified": "2022-08-07T22:02:26+00:00",
    "input_file": {}
  },
  {
    "path": "posts/2009-08-08-the-actuarial-toolkit/",
    "title": "The Actuarial Toolkit",
    "description": "Some comments about the lack of proper tools for Actuarial work in Portugal.",
    "author": [
      {
        "name": "Vitor Chagas",
        "url": "https://vchagas69.github.io"
      }
    ],
    "date": "2009-08-08",
    "categories": [
      "actuary",
      "excel",
      "r-project"
    ],
    "contents": "\nTraditionally, at least in Portugal, actuaries are considered as “Jack\nof all trades” in their working places, being asked to do all sort\nof «technical» tasks. Mainly because they are able to do these tasks,\nfast and accurately, even though, most of them lay outside their\nresponsibility area.\nThere’s not much that can be done about that. As such, I don’t think\nit’s efficient or wise, that Microsoft Excel,\nshould be almost the only tool used by a great majority of the\nactuaries. I’m not discarding it’s versatility, specially if we are\nconsidering it’s macro programming facilities with Visual Basic for\nApplications (VBA).\nBut a spreadsheet, as it’s name implies, was created to be used as\nlarge sheet (of paper) to do some type of calculations. All the rest are\nconvenience functionalities. It was not designed to be used as a\ndatabase or to design charts, even if it is widely used, for that, all\nover the world. It is a generalist rather than a specialist tool for\nthese tasks, as such it’s limitations (some have been addressed in the\nlatest versions).\nThe workload increases every month and there is a pressing need to do\nmore in the same time frame. Upgrading to faster computers isn’t a\nviable option, it just delays the problem.\nActuaries need to use other tools that allow to work faster and do\nthings that Excel simply can’t do.\nThey need to build their own actuarial toolkit.\nJust to finish this post, some years ago I found one tool that became\nfundamental to my loss reserving work. It’s called R\n(www.r-project.org) and, in my opinion, probably the most versatile\npiece of software I’ve ever seen for mathematical type of work.\n\n\n\n",
    "preview": {},
    "last_modified": "2022-08-07T21:44:38+00:00",
    "input_file": {}
  },
  {
    "path": "posts/2009-08-01-welcome/",
    "title": "Welcome",
    "description": "Welcome to my blog, A Portuguese Actuary. I hope you enjoy \nreading what I have to say!",
    "author": [
      {
        "name": "Vitor Chagas",
        "url": "https://vchagas69.github.io"
      }
    ],
    "date": "2009-08-01",
    "categories": [],
    "contents": "\nBeing this the first post, it would be the perfect place to state\nwhat I intend to accomplish with the blog.\nThe idea was to have a place where I could document my findings\nregarding literature, techniques and software that could simplify (my)\nwork as an actuary.\nHopefully it will be helpful for someone else (than me) and I\napologize for my English :)\nNote: I’m compiling and translating from Portuguese\nsome posts from my other blogs.\n\n\n\n",
    "preview": {},
    "last_modified": "2022-08-07T21:19:56+00:00",
    "input_file": {}
  }
]
